// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: storages.sql

package db

import (
	"context"
)

const createBucket = `-- name: CreateBucket :exec
INSERT INTO buckets
  (id, name, storage_id)
VALUES
  ($1, $2, $3)
`

type CreateBucketParams struct {
	ID        string
	Name      string
	StorageID string
}

func (q *Queries) CreateBucket(ctx context.Context, arg CreateBucketParams) error {
	_, err := q.db.Exec(ctx, createBucket, arg.ID, arg.Name, arg.StorageID)
	return err
}

const createContent = `-- name: CreateContent :exec
INSERT INTO contents
  (id, item_id, path, file_type)
VALUES
  ($1, $2, $3, $4)
`

type CreateContentParams struct {
	ID       string
	ItemID   string
	Path     string
	FileType string
}

func (q *Queries) CreateContent(ctx context.Context, arg CreateContentParams) error {
	_, err := q.db.Exec(ctx, createContent,
		arg.ID,
		arg.ItemID,
		arg.Path,
		arg.FileType,
	)
	return err
}

const createContents = `-- name: CreateContents :exec
INSERT INTO contents
  (id, item_id, path, file_type)
VALUES
  (
    UNNEST($1::VARCHAR(36)[]),
    UNNEST($2::VARCHAR(36)[]),
    UNNEST($3::VARCHAR(2100)[]),
    UNNEST($4::VARCHAR(64)[])
  )
`

type CreateContentsParams struct {
	Ids       []string
	ItemIds   []string
	Paths     []string
	FileTypes []string
}

func (q *Queries) CreateContents(ctx context.Context, arg CreateContentsParams) error {
	_, err := q.db.Exec(ctx, createContents,
		arg.Ids,
		arg.ItemIds,
		arg.Paths,
		arg.FileTypes,
	)
	return err
}

const createStorage = `-- name: CreateStorage :exec
INSERT INTO storages
  (id, owner_id)
VALUES
  ($1, $2)
`

type CreateStorageParams struct {
	ID      string
	OwnerID string
}

func (q *Queries) CreateStorage(ctx context.Context, arg CreateStorageParams) error {
	_, err := q.db.Exec(ctx, createStorage, arg.ID, arg.OwnerID)
	return err
}

const deleteBucket = `-- name: DeleteBucket :exec
DELETE FROM buckets
WHERE id = $1
`

func (q *Queries) DeleteBucket(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteBucket, id)
	return err
}

const deleteByBucketID = `-- name: DeleteByBucketID :exec
DELETE FROM items
WHERE bucket_id = $1
`

func (q *Queries) DeleteByBucketID(ctx context.Context, bucketID string) error {
	_, err := q.db.Exec(ctx, deleteByBucketID, bucketID)
	return err
}

const deleteItemTree = `-- name: DeleteItemTree :exec
DELETE FROM items AS i
WHERE i.bucket_id = $1
  AND lft BETWEEN (SELECT l.lft FROM items AS l WHERE l.id = $2) AND (SELECT r.rgt FROM items AS r WHERE r.id = $2)
`

type DeleteItemTreeParams struct {
	BucketID string
	ID       string
}

func (q *Queries) DeleteItemTree(ctx context.Context, arg DeleteItemTreeParams) error {
	_, err := q.db.Exec(ctx, deleteItemTree, arg.BucketID, arg.ID)
	return err
}

const deleteStorage = `-- name: DeleteStorage :exec
DELETE FROM storages
WHERE owner_id = $1
`

func (q *Queries) DeleteStorage(ctx context.Context, ownerID string) error {
	_, err := q.db.Exec(ctx, deleteStorage, ownerID)
	return err
}

const findBucketByID = `-- name: FindBucketByID :one
SELECT 
  id,
  name,
  storage_id,
  (
    SELECT
        i.id
    FROM items AS i
    WHERE i.bucket_id = buckets.id
      AND lft = (SELECT MIN(lft) FROM items WHERE bucket_id = buckets.id)
  ) AS root_directory_id
FROM buckets
WHERE buckets.id = $1
`

type FindBucketByIDRow struct {
	ID              string
	Name            string
	StorageID       string
	RootDirectoryID string
}

func (q *Queries) FindBucketByID(ctx context.Context, id string) (FindBucketByIDRow, error) {
	row := q.db.QueryRow(ctx, findBucketByID, id)
	var i FindBucketByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StorageID,
		&i.RootDirectoryID,
	)
	return i, err
}

const findBuckets = `-- name: FindBuckets :many
SELECT
  id,
  name,
  storage_id,
  (
    SELECT
        i.id
    FROM items AS i
    WHERE i.bucket_id = buckets.id
      AND lft = (SELECT MIN(lft) FROM items WHERE bucket_id = buckets.id)
  ) AS root_directory_id
FROM buckets
WHERE storage_id = $1
`

type FindBucketsRow struct {
	ID              string
	Name            string
	StorageID       string
	RootDirectoryID string
}

// buckets
func (q *Queries) FindBuckets(ctx context.Context, storageID string) ([]FindBucketsRow, error) {
	rows, err := q.db.Query(ctx, findBuckets, storageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBucketsRow
	for rows.Next() {
		var i FindBucketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StorageID,
			&i.RootDirectoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByItemID = `-- name: FindByItemID :many
SELECT id, item_id, path, file_type, created_at
FROM contents
WHERE item_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindByItemID(ctx context.Context, itemID string) ([]Content, error) {
	rows, err := q.db.Query(ctx, findByItemID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Content
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Path,
			&i.FileType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDirectChildren = `-- name: FindDirectChildren :many
SELECT c.id, c.name, c.is_file, c.bucket_id, c.lft, c.rgt
FROM items AS c
JOIN items AS p
ON p.id = $1 AND c.bucket_id = p.bucket_id AND p.lft < c.lft AND c.rgt < p.rgt
WHERE NOT EXISTS (
  SELECT 1
  FROM items AS m
  WHERE m.bucket_id = p.bucket_id
    AND m.lft BETWEEN p.lft AND p.rgt -- 親に含まれている
    AND c.lft BETWEEN m.lft AND m.rgt -- 子供がいる
    AND m.id NOT IN (c.id, p.id) -- 同じitemでない
)
`

type FindDirectChildrenRow struct {
	ID       string
	Name     string
	IsFile   bool
	BucketID string
	Lft      int64
	Rgt      int64
}

func (q *Queries) FindDirectChildren(ctx context.Context, id string) ([]FindDirectChildrenRow, error) {
	rows, err := q.db.Query(ctx, findDirectChildren, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDirectChildrenRow
	for rows.Next() {
		var i FindDirectChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsFile,
			&i.BucketID,
			&i.Lft,
			&i.Rgt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findItemByID = `-- name: FindItemByID :one
SELECT id, name, is_file, bucket_id, lft, rgt
FROM items
WHERE id = $1
`

type FindItemByIDRow struct {
	ID       string
	Name     string
	IsFile   bool
	BucketID string
	Lft      int64
	Rgt      int64
}

func (q *Queries) FindItemByID(ctx context.Context, id string) (FindItemByIDRow, error) {
	row := q.db.QueryRow(ctx, findItemByID, id)
	var i FindItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsFile,
		&i.BucketID,
		&i.Lft,
		&i.Rgt,
	)
	return i, err
}

const findItemsWithDepth = `-- name: FindItemsWithDepth :many
WITH dir_items AS (
  SELECT id, name, is_file, bucket_id, lft, rgt
  FROM items AS i
  WHERE EXISTS (
      SELECT 1 FROM items AS e
      WHERE e.id = $2
        AND e.bucket_id = i.bucket_id
        AND e.is_file = FALSE
        AND i.lft BETWEEN e.lft AND e.rgt
    )
)
SELECT
  c.id,
  c.name,
  c.is_file,
  c.bucket_id,
  c.lft, c.rgt,
  COALESCE((
    SELECT id
    FROM dir_items
    WHERE lft = MAX(CASE WHEN p.id = c.id THEN 0 ELSE p.lft END)
    ), ''
  )::VARCHAR(36) AS parent_id
FROM dir_items AS p
JOIN dir_items AS c ON c.lft BETWEEN p.lft AND p.rgt
GROUP BY c.id, c.name, c.is_file, c.bucket_id, c.lft, c.rgt
HAVING (COUNT(*) - 1) <= $1
`

type FindItemsWithDepthParams struct {
	Depth  interface{}
	ItemID string
}

type FindItemsWithDepthRow struct {
	ID       string
	Name     string
	IsFile   bool
	BucketID string
	Lft      int64
	Rgt      int64
	ParentID string
}

func (q *Queries) FindItemsWithDepth(ctx context.Context, arg FindItemsWithDepthParams) ([]FindItemsWithDepthRow, error) {
	rows, err := q.db.Query(ctx, findItemsWithDepth, arg.Depth, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindItemsWithDepthRow
	for rows.Next() {
		var i FindItemsWithDepthRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsFile,
			&i.BucketID,
			&i.Lft,
			&i.Rgt,
			&i.ParentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestContent = `-- name: FindLatestContent :one
SELECT id, item_id, path, file_type, created_at
FROM contents
ORDER BY created_at DESC
LIMIT 1
`

// contents
func (q *Queries) FindLatestContent(ctx context.Context) (Content, error) {
	row := q.db.QueryRow(ctx, findLatestContent)
	var i Content
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Path,
		&i.FileType,
		&i.CreatedAt,
	)
	return i, err
}

const findLatestContentsByItemIDs = `-- name: FindLatestContentsByItemIDs :many
SELECT c.id, c.item_id, c.path, c.file_type, c.created_at
FROM contents AS c
WHERE c.item_id = ANY ($1::VARCHAR(36)[])
  AND NOT EXISTS (
    SELECT 1
    FROM contents AS c2
    WHERE c.item_id = c2.item_id
      AND c.created_at < c2.created_at
  )
`

func (q *Queries) FindLatestContentsByItemIDs(ctx context.Context, itemIds []string) ([]Content, error) {
	rows, err := q.db.Query(ctx, findLatestContentsByItemIDs, itemIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Content
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Path,
			&i.FileType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRootItemID = `-- name: FindRootItemID :one
SELECT id
FROM items
WHERE bucket_id = $1 AND lft = 1
`

// items
func (q *Queries) FindRootItemID(ctx context.Context, bucketID string) (string, error) {
	row := q.db.QueryRow(ctx, findRootItemID, bucketID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const findStorageByOwnerID = `-- name: FindStorageByOwnerID :one
SELECT id, owner_id FROM storages
WHERE owner_id = $1
`

// storages
func (q *Queries) FindStorageByOwnerID(ctx context.Context, ownerID string) (Storage, error) {
	row := q.db.QueryRow(ctx, findStorageByOwnerID, ownerID)
	var i Storage
	err := row.Scan(&i.ID, &i.OwnerID)
	return i, err
}

const insertItems = `-- name: InsertItems :exec
INSERT INTO items
  (id, name, is_file, bucket_id, lft, rgt)
VALUES
  (
    UNNEST($1::VARCHAR(36)[]),
    UNNEST($2::VARCHAR(256)[]),
    UNNEST($3::BOOL[]),
    UNNEST($4::varchar(36)[]),
    UNNEST($5::BIGINT[]),
    UNNEST($6::BIGINT[])
  )
`

type InsertItemsParams struct {
	Ids       []string
	Names     []string
	IsFiles   []bool
	BucketIds []string
	Lfts      []int64
	Rgts      []int64
}

func (q *Queries) InsertItems(ctx context.Context, arg InsertItemsParams) error {
	_, err := q.db.Exec(ctx, insertItems,
		arg.Ids,
		arg.Names,
		arg.IsFiles,
		arg.BucketIds,
		arg.Lfts,
		arg.Rgts,
	)
	return err
}

const shiftEmptyItemRange = `-- name: ShiftEmptyItemRange :exec
UPDATE items
SET lft = (CASE WHEN lft > $1 THEN lft - ($2 - $1 + 1) ELSE lft END),
    rgt = (CASE WHEN rgt > $2 THEN rgt - ($2 - $1 + 1) ELSE rgt END)
WHERE bucket_id = $3 AND (lft > $1 OR rgt > $2)
`

type ShiftEmptyItemRangeParams struct {
	Lft      int64
	Rgt      interface{}
	BucketID string
}

func (q *Queries) ShiftEmptyItemRange(ctx context.Context, arg ShiftEmptyItemRangeParams) error {
	_, err := q.db.Exec(ctx, shiftEmptyItemRange, arg.Lft, arg.Rgt, arg.BucketID)
	return err
}

const spreadItemRange = `-- name: SpreadItemRange :exec
UPDATE items
SET lft = (CASE WHEN lft > $1 THEN lft + 2 * $2 ELSE lft END),
    rgt = (CASE WHEN rgt > $1 THEN rgt + 2 * $2 ELSE rgt END)
WHERE bucket_id = $3 AND rgt > $1
`

type SpreadItemRangeParams struct {
	Rgt      int64
	Num      interface{}
	BucketID string
}

func (q *Queries) SpreadItemRange(ctx context.Context, arg SpreadItemRangeParams) error {
	_, err := q.db.Exec(ctx, spreadItemRange, arg.Rgt, arg.Num, arg.BucketID)
	return err
}

const updateBucket = `-- name: UpdateBucket :exec
UPDATE buckets
SET name = $1
WHERE id = $2
`

type UpdateBucketParams struct {
	Name string
	ID   string
}

func (q *Queries) UpdateBucket(ctx context.Context, arg UpdateBucketParams) error {
	_, err := q.db.Exec(ctx, updateBucket, arg.Name, arg.ID)
	return err
}
