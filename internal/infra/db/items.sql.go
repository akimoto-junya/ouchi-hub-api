// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: items.sql

package db

import (
	"context"
)

const deleteItemTree = `-- name: DeleteItemTree :exec
DELETE FROM items AS i
WHERE i.work_id = $1
  AND lft BETWEEN (SELECT l.lft FROM items AS l WHERE l.id = $2) AND (SELECT r.rgt FROM items AS r WHERE r.id = $2)
`

type DeleteItemTreeParams struct {
	WorkID string
	ID     string
}

func (q *Queries) DeleteItemTree(ctx context.Context, arg DeleteItemTreeParams) error {
	_, err := q.db.Exec(ctx, deleteItemTree, arg.WorkID, arg.ID)
	return err
}

const findDirectChildren = `-- name: FindDirectChildren :many
SELECT c.id
FROM items AS c
JOIN items AS p
ON p.id = $1 AND c.work_id = p.work_id AND p.lft < c.lft AND c.rgt < p.rgt
WHERE NOT EXISTS (
  SELECT 1
  FROM items AS m
  WHERE m.work_id = p.work_id
    AND m.lft BETWEEN p.lft AND p.rgt -- 親に含まれている
    AND c.lft BETWEEN m.lft AND m.rgt -- 子供がいる
    AND m.id NOT IN (c.id, p.id) -- 同じitemでない
)
`

func (q *Queries) FindDirectChildren(ctx context.Context, id string) ([]string, error) {
	rows, err := q.db.Query(ctx, findDirectChildren, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findItemByID = `-- name: FindItemByID :one
SELECT id, lft, rgt
FROM items
WHERE id = $1
`

type FindItemByIDRow struct {
	ID  string
	Lft int64
	Rgt int64
}

func (q *Queries) FindItemByID(ctx context.Context, id string) (FindItemByIDRow, error) {
	row := q.db.QueryRow(ctx, findItemByID, id)
	var i FindItemByIDRow
	err := row.Scan(&i.ID, &i.Lft, &i.Rgt)
	return i, err
}

const findRootItemID = `-- name: FindRootItemID :one
SELECT id
FROM items
WHERE work_id = $1 AND lft = 1
`

func (q *Queries) FindRootItemID(ctx context.Context, workID string) (string, error) {
	row := q.db.QueryRow(ctx, findRootItemID, workID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const insertItems = `-- name: InsertItems :exec
INSERT INTO items
  (id, name, type_id, work_id,  lft, rgt)
VALUES
  (
    UNNEST($1::VARCHAR(64)[]),
    UNNEST($2::VARCHAR(255)[]),
    UNNEST($3::VARCHAR(64)[]),
    UNNEST($4::varchar(64)[]),
    UNNEST($5::BIGINT[]),
    UNNEST($6::BIGINT[])
  )
`

type InsertItemsParams struct {
	Ids     []string
	Names   []string
	TypeIds []string
	WorkIds []string
	Lfts    []int64
	Rgts    []int64
}

func (q *Queries) InsertItems(ctx context.Context, arg InsertItemsParams) error {
	_, err := q.db.Exec(ctx, insertItems,
		arg.Ids,
		arg.Names,
		arg.TypeIds,
		arg.WorkIds,
		arg.Lfts,
		arg.Rgts,
	)
	return err
}

const shiftEmptyItemRange = `-- name: ShiftEmptyItemRange :exec
UPDATE items
SET lft = (CASE WHEN lft > $1 THEN lft - ($2 - $1 + 1) ELSE lft END),
    rgt = (CASE WHEN rgt > $2 THEN rgt - ($2 - $1 + 1) ELSE rgt END)
WHERE work_id = $3 AND (lft > $1 OR rgt > $2)
`

type ShiftEmptyItemRangeParams struct {
	Lft    int64
	Rgt    interface{}
	WorkID string
}

func (q *Queries) ShiftEmptyItemRange(ctx context.Context, arg ShiftEmptyItemRangeParams) error {
	_, err := q.db.Exec(ctx, shiftEmptyItemRange, arg.Lft, arg.Rgt, arg.WorkID)
	return err
}

const spreadItemRange = `-- name: SpreadItemRange :exec
UPDATE items
SET lft = (CASE WHEN lft > $1 THEN lft + 2 * $2 ELSE lft END),
    rgt = (CASE WHEN rgt > $1 THEN rgt + 2 * $2 ELSE rgt END)
WHERE work_id = $3 AND rgt > $1
`

type SpreadItemRangeParams struct {
	Rgt    int64
	Num    interface{}
	WorkID string
}

func (q *Queries) SpreadItemRange(ctx context.Context, arg SpreadItemRangeParams) error {
	_, err := q.db.Exec(ctx, spreadItemRange, arg.Rgt, arg.Num, arg.WorkID)
	return err
}
